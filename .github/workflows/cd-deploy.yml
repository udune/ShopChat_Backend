name: Deploy to GCP VM Instance

on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  VM_INSTANCE_NAME: ${{ secrets.VM_INSTANCE_NAME }}
  VM_ZONE: ${{ secrets.VM_ZONE }}
  APP_NAME: feedshop-backend
  DEPLOY_PATH: /home/deploy/feedshop-backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "gradle"

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build Application
        run: ./gradlew clean build -x test
        env:
          SPRING_PROFILES_ACTIVE: prod

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Create deployment package
        run: |
          echo "Creating deployment package..."
          mkdir -p deploy-package
          
          # JAR 파일 복사
          cp build/libs/*.jar deploy-package/app.jar
          
          # Dockerfile 복사
          cp Dockerfile deploy-package/
          
          # docker-compose.yml 생성 (모든 환경변수 포함)
          cat > deploy-package/docker-compose.yml << 'EOF'
          version: '3.8'
          
          services:
            feedshop-backend:
              build: .
              container_name: feedshop-backend
              ports:
                - "8080:8080"
              environment:
                # 기본 Spring 설정
                - SPRING_PROFILES_ACTIVE=prod
          
                # 데이터베이스 설정
                - DB_HOST=${{ secrets.VM_DB_HOST }}
                - DB_PORT=${{ secrets.VM_DB_PORT }}
                - DB_NAME=${{ secrets.DB_NAME }}
                - DB_USERNAME=${{ secrets.VM_DB_USERNAME }}
                - DB_PASSWORD=${{ secrets.VM_DB_PASSWORD }}
          
                # JWT 및 보안 설정
                - JWT_SECRET=${{ secrets.JWT_SECRET }}
                - RECAPTCHA_SECRET_KEY=${{ secrets.RECAPTCHA_SECRET_KEY }}
          
                # 이메일 설정 (Mailgun)
                - MAILGUN_API_KEY=${{ secrets.MAILGUN_API_KEY }}
                - MAILGUN_DOMAIN=${{ secrets.MAILGUN_DOMAIN }}
                - MAILGUN_EMAIL=${{ secrets.MAILGUN_EMAIL }}
          
                # OAuth2 클라이언트 ID/SECRET
                - GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
                - GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
                - KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
                - KAKAO_CLIENT_SECRET=${{ secrets.KAKAO_CLIENT_SECRET }}
          
                # OpenAI 설정
                - OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
                - SPRING_AI_OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          
                # GCP 설정
                - GCS_ID=${{ secrets.GCS_ID }}
                - GCS_BUCKET=${{ secrets.GCS_BUCKET }}
                - SPRING_CLOUD_GCP_PROJECT_ID=${{ secrets.GCS_ID }}
          
                # 애플리케이션 URL 설정
                - APP_CDN_BASE_URL=${{ secrets.APP_CDN_BASE_URL }}
                - APP_PASSWORD_RESET_URL=${{ secrets.APP_PASSWORD_RESET_URL }}
                - APP_VERIFICATION_URL=${{ secrets.APP_VERIFICATION_URL }}
                - APP_OAUTH2_AUTHORIZED_REDIRECT_URI=${{ secrets.APP_OAUTH2_AUTHORIZED_REDIRECT_URI }}
          
                # Spring Security OAuth2 클라이언트 등록 - Google
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_AUTHORIZATION_GRANT_TYPE=authorization_code
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_SCOPE=openid,profile,email
          
                # Spring Security OAuth2 클라이언트 등록 - Kakao
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_CLIENT_SECRET=${{ secrets.KAKAO_CLIENT_SECRET }}
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_REDIRECT_URI=${{ secrets.KAKAO_REDIRECT_URI }}
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_PROVIDER=kakao
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_AUTHORIZATION_GRANT_TYPE=authorization_code
                - SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_KAKAO_SCOPE=profile_nickname,account_email
          
                # Spring Security OAuth2 Provider 설정 - Kakao
                - SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_KAKAO_AUTHORIZATION_URI=https://kauth.kakao.com/oauth/authorize
                - SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_KAKAO_TOKEN_URI=https://kauth.kakao.com/oauth/token
                - SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_KAKAO_USER_INFO_URI=https://kapi.kakao.com/v2/user/me
                - SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_KAKAO_USER_NAME_ATTRIBUTE=id
          
              networks:
                - feedshop-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s
          
          networks:
            feedshop-network:
              driver: bridge
          EOF
          
          # 배포 스크립트 생성
          cat > deploy-package/deploy.sh << 'EOF'
          #!/bin/bash
          
          set -e
          
          echo "=== FeedShop Backend Deployment Starting ==="
          
          # 현재 컨테이너 중지 및 제거
          echo "Stopping existing containers..."
          docker-compose down --remove-orphans || true
          
          # 이전 이미지 정리
          echo "Cleaning up old images..."
          docker image prune -f || true
          
          # 새 컨테이너 빌드 및 시작
          echo "Building and starting new containers..."
          docker-compose up -d --build
          
          # 컨테이너 상태 확인
          echo "Checking container status..."
          sleep 10
          docker-compose ps
          
          # 헬스 체크
          echo "Performing health check..."
          for i in {1..30}; do
            if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
              echo "✅ Health check passed!"
              break
            else
              echo "⏳ Health check attempt $i/30..."
              sleep 10
            fi
          done
          
          if ! curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
            echo "❌ Health check failed after 5 minutes"
            echo "Container logs:"
            docker-compose logs feedshop-backend
            exit 1
          fi
          
          echo "🎉 Deployment completed successfully!"
          EOF
          
          chmod +x deploy-package/deploy.sh

      - name: Copy files to VM instance
        run: |
          echo "Copying deployment package to VM..."
          
          # VM에 배포 디렉터리 생성
          gcloud compute ssh $VM_INSTANCE_NAME \
            --zone=$VM_ZONE \
            --command="sudo mkdir -p $DEPLOY_PATH && sudo chown -R \$USER:\$USER $DEPLOY_PATH"
          
          # 파일 복사
          gcloud compute scp --recurse deploy-package/* \
            $VM_INSTANCE_NAME:$DEPLOY_PATH \
            --zone=$VM_ZONE

      - name: Deploy application on VM
        run: |
          echo "Deploying application on VM..."
          
          gcloud compute ssh $VM_INSTANCE_NAME \
            --zone=$VM_ZONE \
            --command="
              cd $DEPLOY_PATH && 
              echo '=== Starting deployment ===' &&
              chmod +x deploy.sh &&
              ./deploy.sh
            "

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # VM의 외부 IP 가져오기
          VM_EXTERNAL_IP=$(gcloud compute instances describe $VM_INSTANCE_NAME \
            --zone=$VM_ZONE \
            --format='get(networkInterfaces[0].accessConfigs[0].natIP)')
          
          echo "VM External IP: $VM_EXTERNAL_IP"
          
          # 방화벽 규칙 확인/생성
          if ! gcloud compute firewall-rules describe allow-feedshop-8080 > /dev/null 2>&1; then
            echo "Creating firewall rule for port 8080..."
            gcloud compute firewall-rules create allow-feedshop-8080 \
              --allow tcp:8080 \
              --source-ranges 0.0.0.0/0 \
              --description "Allow FeedShop backend on port 8080"
          fi
          
          # 서비스 URL 설정
          SERVICE_URL="http://$VM_EXTERNAL_IP:8080"
          echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
          
          echo "🔗 Service URL: $SERVICE_URL"
          echo "📊 Health Check: $SERVICE_URL/actuator/health"
          echo "📖 API Docs: $SERVICE_URL/swagger-ui/index.html"

      - name: Final health check
        run: |
          echo "Performing final health check..."
          
          # 30초 대기 (서비스 완전 시작 대기)
          sleep 30
          
          # VM에서 직접 헬스 체크
          gcloud compute ssh $VM_INSTANCE_NAME \
            --zone=$VM_ZONE \
            --command="
              echo 'Local health check:' &&
              curl -f http://localhost:8080/actuator/health || {
                echo 'Local health check failed, checking logs:' &&
                docker-compose -f $DEPLOY_PATH/docker-compose.yml logs --tail=50 feedshop-backend
                exit 1
              }
            "
          
          echo "✅ Deployment verification completed!"

  notification:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Notify Deployment Status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "🚀 Deployment to VM completed successfully!"
            echo "📊 Instance: ${{ env.VM_INSTANCE_NAME }}"
            echo "🌏 Zone: ${{ env.VM_ZONE }}"
            echo "🔗 URL: ${{ env.SERVICE_URL }}"
          else
            echo "❌ Deployment failed!"
            exit 1
          fi